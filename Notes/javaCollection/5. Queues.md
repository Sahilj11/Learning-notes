## Intro
A queue is a collection designed to hold elements for processing, yielding them up in
the order in which they are to be processed. The corresponding Collections Framework
interface Queue (see Figure 14-1) has a number of different implementations

Many of the implementations use the
rule that tasks are to be processed in the order in which they were submitted (First In
First Out, or FIFO), but other rules are possible like storing data on basis of there priority

In addition to the operations inherited from Collection, the Queue interface includes
operations to add an element to the tail of the queue, to inspect the element at its head,
or to remove the element at its head. Each of these three operations comes in two
varieties, one which returns a value to indicate failure and one which throws an ex-
ception.


![[Pasted image 20231016111001.png]]

![[Pasted image 20231016111015.png]]

### Adding element to queue 
Although add does return a boolean signifying its success in inserting an element, that value can’t be used to report that a boun-
ded queue is full; the contract for add specifies that it may return false only if the
collection refused the element because it was already present—otherwise, it must throw
an exception.

The value-returning variant is offer:
```java
boolean offer (E e)
// insert the given element if possible
```
The value returned by offer indicates whether the element was successfully inserted
or not. Note that offer does throw an exception if the element is illegal in some way

### Retrieving element from queue
The methods in this group are peek and ele
ment for inspecting the head element, and poll and remove for removing it from the
queue and returning its value.
The methods that throw an exception for an empty queue are:
```java
E element()
E remove()
// retrieve but do not remove the head element
// retrieve and remove the head element
```
Notice that this is a different method from the Collection method remove(Object). The
methods that return null for an empty queue are:
```java
E peek()
E poll()
// retrieve but do not remove the head element
// retrieve and remove the head element
```
Because these methods return null to signify that the queue is empty, you should avoid
using null as a queue element. In general, the use of null as a queue element is dis-
couraged by the Queue interface, and the only standard implementation that allows it
is the legacy implementation LinkedList.

## Implementation of queue 
### Priority queue
PriorityQueue is one of the two nonlegacy Queue implementations not designed pri-
marily for concurrent use (the other one is ArrayDeque)
#### What is concurrent use
In the context of data structures and programming, "concurrent use" refers to the ability of multiple threads or processes to access and manipulate the data structure simultaneously. When multiple threads or processes can operate on a data structure concurrently, it introduces the potential for race conditions and other concurrency-related issues, which can lead to unpredictable and often undesirable behavior in your program.

Java's `PriorityQueue` is one of the two non-legacy Queue implementations that are not explicitly designed for concurrent use. This means that `PriorityQueue` is not thread-safe by default. Thread-safety in this context means that the data structure is not protected against concurrent access and modification by multiple threads. When multiple threads are involved, you need to implement your own synchronization mechanisms (e.g., using locks or other concurrency control tools) to ensure that the `PriorityQueue` is accessed and modified safely.

If you need to use a queue in a multi-threaded environment, Java provides a few concurrent queue implementations like `ConcurrentLinkedQueue`, `ConcurrentLinkedDeque`, and `LinkedBlockingQueue`, among others. These classes are explicitly designed to handle concurrent access, and they provide built-in synchronization mechanisms to ensure that multiple threads can safely use the queue without causing data corruption or race conditions.

#### How PQ handle equals
PriorityQueue gives no guarantee of how it presents multiple elements with the same value. So if, in our example, several tasks are tied for the highest priority in the queue, it will
choose one of them arbitrarily as the head element.

#### Constructor 
```java
PriorityQueue()
// natural ordering, default initial capacity (11)
PriorityQueue(Collection<? extends E> c)
// natural ordering of elements taken from c, unless
// c is a PriorityQueue or SortedSet, in which case
// copy c's ordering
PriorityQueue(int initialCapacity)
// natural ordering, specified initial capacity
PriorityQueue(int initialCapacity, Comparator<? super E> comparator)
// Comparator ordering, specified initial capacity
PriorityQueue(PriorityQueue<? extends E> c)
// ordering and elements copied from c
PriorityQueue(SortedSet<? extends E> c)
// ordering and elements copied from c
```

